<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs"  encoding="UTF8" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#
//
// Configurations:
// ----
bool useCulture = false;
string appName = "CachedResources";
string version = "1.0.1.0";
string accessibility = "public";
string ns = (string)System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint");
string resxFileName = Path.ChangeExtension(Host.TemplateFile, ".resx");
string resxClassName =  Path.GetFileNameWithoutExtension(Host.TemplateFile);
string proxyClassName = string.Format("Cached{0}", resxClassName);
XDocument document = XDocument.Parse(File.ReadAllText(resxFileName));

// DO NOT CHANGE THE TEMPLATE UNDER THIS LINE!!

#>// "Therefore those skilled at the unorthodox
// are infinite as heaven and earth,
// inexhaustible as the great rivers.
// When they come to an end,
// they bagin again,
// like the days and months;
// they die and are reborn,
// like the four seasons."
// 
// - Sun Tsu,
// "The Art of War"

// ---
//  This code was generated by Resource extnsions template for T4 C#
//
//  DO NOT CHANGE THIS FILE!
//	Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System.Drawing;

namespace <#=ns#>
{
	// ReSharper disable InconsistentNaming
	// ReSharper disable ResourceItemNotResolved
    
	/// <summary>
    /// Represent a cached resources class for "<#= resxClassName #>" resources.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute]
    [System.CodeDom.Compiler.GeneratedCode("<#= appName #>", "<#= version #>")]
    <#= accessibility #> static class <#= proxyClassName #>
    {
		#region Fields and Consts

<# 
	foreach(var item in document.Element("root").Elements("data")) 
	{ 
        if (IsHandled(item))
        {
#>
		private static <#= GetType(item) #> <#= GetFieldName(item) #>;
<#
		}
	}
#>

		#endregion
		
<# 
	foreach(var item in document.Element("root").Elements("data")) 
	{ 
        if (IsHandled(item))
        {
#>		
		/// <summary>
        /// Get the cached bitmap image of "<#= item.Attribute("name").Value #>" resource.<br/>
		/// On first call the image is cached, all subsequent calls will return the same image object.
        /// </summary>
		public static <#= GetType(item) #> <#= GetPropName(item) #>
		{
			get 
			{
				if(<#= GetFieldName(item) #> == null)
					<#= GetFieldName(item) #> = (<#= GetType(item) #>)<#= resxClassName #>.ResourceManager.GetObject("<#= GetName(item) #>"<#if(useCulture) {#>, <#= resxClassName #>.Culture <#}#>);
				return <#= GetFieldName(item) #>;
			}
		}
<#
		}
	}
#>

		/// <summary>
        /// Clear all cached images.
        /// </summary>
		public static void ClearCache()
		{
<# 
		foreach(var item in document.Element("root").Elements("data")) 
		{ 
        if (IsHandled(item))
        {
#>
			var <#= GetName(item) #>2 = <#= GetFieldName(item) #>;
			<#= GetFieldName(item) #> = null;
			if( <#= GetName(item) #>2 != null)
				<#= GetName(item) #>2.Dispose();

<#
		}
	}
#>
		}
    }

	// ReSharper restore ResourceItemNotResolved
	// ReSharper restore InconsistentNaming
}

<#+
public bool IsHandled(XElement item)
{
	return item.Value.Contains("System.Drawing.Bitmap") || item.Value.Contains("System.Drawing.Icon");
}

public string GetType(XElement item)
{
	if(item.Value.Contains("System.Drawing.Bitmap"))
		return "Bitmap";
	if(item.Value.Contains("System.Drawing.Icon"))
		return "Icon";
	return "Unknown";
}

public string GetName(XElement item)
{
	return item.Attribute("name").Value;
}

public string GetPropName(XElement item)
{
	var str = item.Attribute("name").Value;
	return char.ToUpper(str[0]) + str.Substring(1);
}

public string GetFieldName(XElement item)
{
	return "_" + item.Attribute("name").Value;
}
#>